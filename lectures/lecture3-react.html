
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">  
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noindex, nofollow" />
    
        <title>CSCI312 Spring 2023</title>
        <meta name="description" content="CSCI312 at Middlebury College
">

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" crossorigin="anonymous">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" >
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/vs2015.min.css" integrity="sha512-w8aclkBlN3Ha08SMwFKXFJqhSUx2qlvTBFLLelF8sm4xQnlg64qmGB/A6pBIKy0W8Bo51yDMDtQiPLNRq1WMcQ==" crossorigin="anonymous" />

        <link rel="stylesheet" href="/~mlinderman/courses/cs312/s23/css/main.css">
        <link rel="canonical" href="http://localhost:4000/~mlinderman/courses/cs312/s23/lectures/lecture3-react.html">
    </head>
    <body>

        <div class="container">
            <h1 id="introduction-to-react">Introduction to React</h1>

<p>React is a framework for just the View in <a href="https://en.wikipedia.org/wiki/Model–view–controller">Model-View-Controller (MVC)</a> design pattern (although not all would agree with that characterization). And in particular it is designed to solve a very specific problem in client side applications: implementing updates to multiple views of the same data.</p>

<p>As an example we will create a RGB color picker similar in spirit to this <a href="https://www.w3schools.com/colors/colors_rgb.asp">example</a>, with three sliders (R, G and B) that control a color swatch. Check out a “vanilla JS” example <a href="https://codepen.io/mlinderm/pen/NWqPbeq">here</a> as a starting point. For each color component we have three “views”: 1) the position of the slider itself, 2) the numeric value label, and 3) the color swatch. All three need to be updated when we change that color component. How can we do so? What design patterns could be relevant?</p>

<ul>
  <li>Event-based model (e.g. Backbone): Changing the data triggers an event. Views can register for those events and update themselves when notified.</li>
  <li>Two-way binding (e.g., Angular): Assigning to a value propagates the data to dependent components and components, e.g. an input, can make updates that “flow back”.</li>
  <li>Efficient re-rendering (e.g. React): React takes a simpler approach... just re-render all of the components when the data changes.</li>
</ul>

<p>A key innovation in React is making that re-rendering process very <a href="https://calendar.perfplanet.com/2013/diff/">fast</a>.  React maintains a virtual DOM that represents the ideal state of the UI.  Changing the application state triggers re-rendering, which changes the virtual DOM (those changes are fast since only the “virtual” DOM is changing). Any differences between the virtual DOM and actual DOM<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> that is rendered by the browser are then reconciled to the bring the actual DOM to the desired state. But only those elements that changed are updated making this process more efficient.</p>

<p>Those operations on the (virtual) DOM are the “part that is the same” and occur entirely “behind the scenes” within React. As a developer your focus is just on rendering the desired UI.</p>

<h3 id="if-react-is-just-the-v-what-about-m--c">If React is just the V, what about M &amp; C?</h3>

<p>As we will see React components can be quite sophisticated and incorporate features we might otherwise associate with models and controllers. Related tools like Flux or Redux are sometimes used with React in those roles. Or React is often used for the client side of an application whose server has M &amp; C-like functionality.</p>

<h2 id="react-basic-concepts">React: Basic Concepts</h2>

<h3 id="components">Components</h3>

<p>The fundamental unit of React is the component. In React, we can implement components as either <em>classes</em> or <em>functions</em>. For our purposes, we will primarily stick to function-based components, but many examples you find online will use classes.</p>

<p>A function-based component is a function that takes a single argument, which we refer to as the <em>props</em>, and returns a hierarchy of components (think of these children components like a nested tree, similar to the DOM itself) with a single root. The root element returned by the function is what is added to the virtual DOM.</p>

<p>The first step in building a React app is break down the UI (the view) into a hierarchy of components and sub-components. In the color picker there is one main component (the color picker itself, with the swatch) and the 3 sliders and corresponding value displays.</p>

<h3 id="state">State</h3>

<p>What state do we need? Just the three color components (red, green and blue). Even in the most complex color picker example, all of the view is derived from just those three components.</p>

<p>To add state information to a function component, we will use <a href="https://reactjs.org/docs/hooks-intro.html">hooks</a>. At its simplest, we can create state with the <code>useState()</code> function. This returns an array with a constant value (the current value for our state object, initialized to the value we pass as the argument to <code>useState()</code>) and a setter function for updating the state.</p>

<p>Some notes about state:</p>
<ul>
  <li>Do not modify state directly, instead use the setter function.</li>
  <li>Favor immutable state data (like numbers) so you aren’t tempted to mutate state outside the setter function.</li>
  <li>State updates may be asynchronous. React may batch updates, and so you shouldn’t assume the state has actually changed after the call to the setter.</li>
</ul>

<p>We need to make the values of each color component available to the parent to control the color of swatch. Per the React <a href="https://reactjs.org/docs/lifting-state-up.html">documentation</a>: “Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor.” We will pull the state for the color values up to the parent component <code>ColorPicker</code> and pass those values back down as props to the individual sliders (<code>LabeledSlider</code>).</p>

<p>But, all React components must act like pure functions with respect to their props. That is a component can’t modify its props (this enables efficient updates). Or alternately, think of it as “data flows down” via the props. To communicate updates “back up” we supply a callback to the child that modifies the state in the parent. Using this approach we preserve the data flow invariants expected by React.
With this change the sliders don’t need to know what color they are. All the state is encapsulated in the parent component and passed in the <code>props</code>.</p>

<h3 id="pure-components">Pure Components</h3>

<p>Since the slider doesn’t have any state, it is now considered a “pure component” (and it should be a pure function, i.e. the output is a function only of the inputs with no side effects). React can optimize these considerably, most particularly, it can avoid re-rendering them if the props haven’t changed – even if the parent has re-rendered.</p>

<h2 id="example-react-color-picker">Example React Color Picker</h2>

<p>Check out the complete React color picker implementation:</p>

<p class="codepen" data-height="265" data-theme-id="default" data-default-tab="js,result" data-user="mlinderm" data-slug-hash="JjdYmOK" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Basic Color Picker with Hooks">
  <span>See the Pen <a href="https://codepen.io/mlinderm/pen/JjdYmOK">
  Basic Color Picker with Hooks</a> by Michael Lindermsn (<a href="https://codepen.io/mlinderm">@mlinderm</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async="" src="https://static.codepen.io/assets/embed/ei.js"></script>

<h3 id="react-and-jsx">React and JSX</h3>

<p>Since rendering is tightly coupled with other UI logic in React, React provides JSX, a syntax extension to JavaScript, for describing the elements in the UI. These elements can be simple HTML:</p>

<pre><code class="language-jsx">const heading = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
</code></pre>

<p>or React components:</p>

<pre><code class="language-jsx">const person = &lt;Person name={p.name} address={p.addr} /&gt;;
</code></pre>

<p>The curly braces specify embedded JavaScript. The attributes becomes the props object for the component.</p>

<p>Since JSX is an extension to JavaScript, we will need a compiler to convert it to standard JavaScript. The online sandboxes do that for us (as an option) and the tool we will use for setting up React application (Next) integrates the necessary compiler to transpile JSX (and support features of ES6). We will use JSX in our components (as it is much more concise and clear). However, you should realize that it is being translated into normal JavaScript functions.</p>

<h3 id="controlled-vs-uncontrolled-components">Controlled vs. uncontrolled components</h3>

<p>In creating the color picker, we described the <code>&lt;input&gt;</code> elements as “controlled”. Controlled components are form elements with state controlled by React. Uncontrolled components maintain their own state. The latter is the way<code> &lt;input&gt;</code> elements naturally work (recall the “vanilla JS” color picker).</p>

<p>The former, “controlled”, is the <a href="https://reactjs.org/docs/forms.html#controlled-components">recommended approach</a> as it ensures there is only one source of truth, the React state. We set the <code>&lt;input&gt;</code> element’s value from state, and provide an <code>onChange</code> (or other relevant) handler to update that state in response to user input. Each state change triggers a re-rendering that shows the changes the user just initiated. The React <a href="https://reactjs.org/docs/forms.html#controlled-components">forms documentation</a> has a number of examples of controlled inputs, e.g. for a text input:</p>

<pre><code class="language-jsx">const [title, setTitle] = useState('');

&lt;input
  type="text"
  value={title}
  onChange={(event) =&gt; setTitle(event.target.value)}
/&gt;
</code></pre>

<p>The value of the component is set from the parent’s state and any changes are immediately captured and used to update the parent’s state.</p>

<h2 id="react-in-summary">React in summary</h2>

<ul>
  <li>React implements the View in MVC</li>
  <li>A React application is organized as components</li>
  <li>A component takes in parameters, the “props”, and returns a hierarchy of views to display as React elements</li>
  <li>A React element might be simple HTML, e.g. a <code>&lt;div&gt;</code> or a React component</li>
  <li>This hierarchy of views updates the virtual DOM. Changes to the virtual DOM are efficiently propagated to the actual DOM rendered in the browser in the reconciliation process.</li>
  <li>There (generally) must be a single root object (version 16 added <a href="https://reactjs.org/docs/fragments.html">fragments</a>)</li>
  <li>Components can’t change their props (and parents can’t see their children’s state). Information is passed to parents via callbacks (passed in the props).</li>
  <li>Components can be classes (the <code>render</code> views), or functions that return views. We will use the latter.</li>
</ul>

<p>As you are starting to work with React, I recommend the <a href="https://reactjs.org/docs/thinking-in-react.html">“Thinking in React”</a> section of the React documentation.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>At a high-level the “DOM” is what the browser renders. More specifically, a web page (or document) is a set of (many) nested boxes, i.e.  nested elements.  The Document Object Model (DOM) is the tree data structure representing the nested structure of the page. The boxes (HTML tags in our context) are nodes in the tree. <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">The DOM properties and methods (the API) provide programmatic access to the tree to access or change the document’s structure, style or content.</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

        </div>

        <footer class="footer">
            <div class="container">
                <hr/ class="divider">
                <em>&copy; Michael Linderman and Christopher Andrews 2019-2023. Last modified at: 2023-02-16 16:44:53 -0500.</em>
            </div>
        </footer>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js" integrity="sha512-s+tOYYcC3Jybgr9mVsdAxsRYlGNq4mlAurOrfNuGMQ/SCofNPu92tjE7YRZCsdEtWL1yGkqk15fU/ark206YTg==" crossorigin="anonymous"></script>
        <script>
            hljs.highlightAll();
        
            const codeBlocks = document.querySelectorAll('.code-header + pre');
            const copyCodeButtons = document.querySelectorAll('.btn-clipboard');

            copyCodeButtons.forEach((copyCodeButton, index) => {
                const code = codeBlocks[index].innerText;

                copyCodeButton.addEventListener('click', () => {
                    window.navigator.clipboard.writeText(code);
                    copyCodeButton.textContent = "Copied!";
                    setTimeout(() => {
                        copyCodeButton.textContent = "Copy";
                    }, 2000);
                });
            });
        </script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
        <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

    </body>
</html>
